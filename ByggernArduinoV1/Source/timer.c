/*
 * timer.c
 *
 * Created: 14.10.2020 08:49:46
 *  Author: thomabsk
 */ 

#include "timer.h"
#include "game_controller.h"

void timer_init(void) {
	// Enable Timer Counter channel 1, 2, 3
	PMC->PMC_PCER0 |= PMC_PCER0_PID27;
	PMC->PMC_PCER0 |= PMC_PCER0_PID28;
	PMC->PMC_PCER0 |= PMC_PCER0_PID29;
	PMC->PMC_PCER0 |= PMC_PCER0_PID30;
	
	//Set up PWM signal to pin 25
	PIOB->PIO_PDR |= PIO_PDR_P25;
	PIOB->PIO_ABSR |= PIO_ABSR_P25;

	TC0->TC_CHANNEL[TIMER_CHANNEL_PWM].TC_CMR |= TC_CMR_WAVE;
	TC0->TC_CHANNEL[TIMER_CHANNEL_PWM].TC_CMR |= TC_CMR_TCCLKS_TIMER_CLOCK1;					//Timer clock = MCK / 2
	TC0->TC_CHANNEL[TIMER_CHANNEL_PWM].TC_CMR |= TC_CMR_WAVSEL_UP_RC;							//Reset counter on RC hit
	TC0->TC_CHANNEL[TIMER_CHANNEL_PWM].TC_CMR |= TC_CMR_ACPC_CLEAR;								//Reset TIOA signal on RC hit
	TC0->TC_CHANNEL[TIMER_CHANNEL_PWM].TC_CMR |= TC_CMR_ACPA_SET;								//Set TIOA signal on RA hit
	TC0->TC_CHANNEL[TIMER_CHANNEL_PWM].TC_RC |= TC_RC_RC((int)(PWM_PERIOD * (MCK / 2)));

	timer_PWM_duty_update(0);																	//Initialize RA to resonable value

	TC0->TC_CHANNEL[TIMER_CHANNEL_PWM].TC_CCR |= TC_CCR_CLKEN | TC_CCR_SWTRG;
	
	// Set up timer interrrupts for encoder reading
	TC0->TC_CHANNEL[TIMER_CHANNEL_ENCODER].TC_CMR |= TC_CMR_WAVE;
	TC0->TC_CHANNEL[TIMER_CHANNEL_ENCODER].TC_CMR |= TC_CMR_TCCLKS_TIMER_CLOCK2;				//Timer clock = MCK / 8
	TC0->TC_CHANNEL[TIMER_CHANNEL_ENCODER].TC_CMR |= TC_CMR_WAVSEL_UP_RC;						//Reset counter on RC hit
	TC0->TC_CHANNEL[TIMER_CHANNEL_ENCODER].TC_IER |= TC_IER_CPCS;
	TC0->TC_CHANNEL[TIMER_CHANNEL_ENCODER].TC_RC |= TC_RC_RC((int)(ENCODER_TIMER_VAL * (MCK / 8)));
	TC0->TC_CHANNEL[TIMER_CHANNEL_ENCODER].TC_CCR |= TC_CCR_CLKEN | TC_CCR_SWTRG;
	
	// Set up timer for PID time stepping
	TC0->TC_CHANNEL[TIMER_CHANNEL_PID].TC_CMR |= TC_CMR_WAVE;
	TC0->TC_CHANNEL[TIMER_CHANNEL_PID].TC_CMR |= TC_CMR_TCCLKS_TIMER_CLOCK2;					//Timer clock = MCK / 8
	TC0->TC_CHANNEL[TIMER_CHANNEL_PID].TC_CMR |= TC_CMR_WAVSEL_UP_RC | TC_CMR_CPCSTOP;			//Reset counter on RC hit
	TC0->TC_CHANNEL[TIMER_CHANNEL_PID].TC_IER |= TC_IER_CPCS;
	TC0->TC_CHANNEL[TIMER_CHANNEL_PID].TC_RC |= TC_RC_RC((int)(PID_TIME_STEP * (MCK / 8)));
	TC0->TC_CHANNEL[TIMER_CHANNEL_PID].TC_CCR |= TC_CCR_CLKEN | TC_CCR_SWTRG;
	
	// Enable TC1 channel 0 for solenoid pulse
	TC1->TC_CHANNEL[TIMER_CHANNEL_SOLENOID].TC_CMR |= TC_CMR_WAVE;
	TC1->TC_CHANNEL[TIMER_CHANNEL_SOLENOID].TC_CMR |= TC_CMR_TCCLKS_TIMER_CLOCK2;
	TC1->TC_CHANNEL[TIMER_CHANNEL_SOLENOID].TC_CMR |= TC_CMR_WAVSEL_UP_RC | TC_CMR_CPCSTOP;
	TC1->TC_CHANNEL[TIMER_CHANNEL_SOLENOID].TC_IER |= TC_IER_CPCS;
	TC1->TC_CHANNEL[TIMER_CHANNEL_SOLENOID].TC_RC |= TC_RC_RC(SOLENOID_PULSE_DURATION * (MCK / 8));
}

//Duty in percent
void timer_PWM_duty_update(double duty) {
	if ((duty < PWM_MIN_DUTY) || (duty > PWM_MAX_DUTY)) {
		duty = (PWM_MIN_DUTY + PWM_MAX_DUTY) / 2;			//Set to middle off allowed duty span if duty is outside range
	}

	int RA_val = (100 - duty) * (PWM_PERIOD * (MCK / 2));

	TC0->TC_CHANNEL[TIMER_CHANNEL_PWM].TC_RA = TC_RA_RA(RA_val);
}


void TC1_Handler(void) {
	uint32_t dummy = TC0->TC_CHANNEL[TIMER_CHANNEL_ENCODER].TC_SR;
	NVIC_ClearPendingIRQ(TC1_IRQn);
	WDT->WDT_CR |= (WDT_CR_KEY_PASSWD | WDT_CR_WDRSTT);
}